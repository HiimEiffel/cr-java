#!/usr/bin/php
<?php
const MESSAGES_URL = 'https://raw.githubusercontent.com/royale-proxy/node-cr-proxy/master/enums/emsg.js';
const INDENT = "\t";
const INDENT2 = INDENT . INDENT;


echo 'Downloading messages...', PHP_EOL;
$messagesText = file_get_contents(MESSAGES_URL);

echo 'Parsing messages...', PHP_EOL;
$lines = explode(PHP_EOL, $messagesText);
$status = 0;
$type = 0;
$messages = [
	'client' => [],
	'server' => []
];
$definedMessages = [];
foreach ($lines as $line) {
	switch ($status) {
	case 0:
		if ($line === 'module.exports = {') {
			$status = 1;
		}
		break;
	case 1:
		switch ($line) {
		case '    // Client Messages':
			$type = 1;
			continue;
		case '    // Server Messages':
			$type = 2;
			continue;
		case '    // Value-to-name mapping for convenience':
			break 3;
		}

		if (preg_match('~\s*\'([^\']*)\': ([^,]*),~', $line, $match) !== 1) {
			break;
		}

		switch ($type) {
		case 1:
			$messages['client'][$match[1]] = intval($match[2]);
			break;
		case 2:
			$messages['server'][$match[1]] = intval($match[2]);
			break;
		}
		break;
	}
}

echo 'Writing messages...', PHP_EOL;
$file = fopen('src/com/tarik02/clashroyale/server/protocol/Info.java', 'w');
fwrite($file, 'package royaleserver.protocol;' . PHP_EOL);
fwrite($file, PHP_EOL);
fwrite($file, 'import java.util.Collections;' . PHP_EOL);
fwrite($file, 'import java.util.HashMap;' . PHP_EOL);
fwrite($file, 'import java.util.Map;' . PHP_EOL);
fwrite($file, PHP_EOL);
fwrite($file, 'public class Info {' . PHP_EOL);
fwrite($file, INDENT . 'private Info() {}' . PHP_EOL);
fwrite($file, PHP_EOL);
fwrite($file, INDENT . '// Client messages' . PHP_EOL);
foreach ($messages['client'] as $name => $id) {
	fwrite($file, INDENT . 'public static final short ' . convertMessageName($name) . ' = ' . $id . ';' . PHP_EOL);
}
fwrite($file, PHP_EOL);
fwrite($file, INDENT . '// Server messages' . PHP_EOL);
foreach ($messages['server'] as $name => $id) {
	fwrite($file, INDENT . 'public static final short ' . convertMessageName($name) . ' = ' . $id . ';' . PHP_EOL);
}
fwrite($file, PHP_EOL);
fwrite($file, INDENT . 'public static final Map<Integer, String> messagesMap = createMessagesMap();' . PHP_EOL);
fwrite($file, PHP_EOL);
fwrite($file, INDENT . 'private static Map<Integer, String> createMessagesMap() {' . PHP_EOL);

fwrite($file, INDENT2 . 'Map<Integer, String> map = new HashMap<>();' . PHP_EOL);
fwrite($file, PHP_EOL);
fwrite($file, INDENT2 . '// Client messages' . PHP_EOL);
foreach ($messages['client'] as $name => $id) {
	fwrite($file, INDENT2 . "map.put($id, \"$name\");" . PHP_EOL);
}
fwrite($file, PHP_EOL);
fwrite($file, INDENT2 . '// Server messages' . PHP_EOL);
foreach ($messages['server'] as $name => $id) {
	fwrite($file, INDENT2 . "map.put($id, \"$name\");" . PHP_EOL);
}
fwrite($file, PHP_EOL);
fwrite($file, INDENT2 . 'return Collections.unmodifiableMap(map);' . PHP_EOL);

fwrite($file, INDENT . '}' . PHP_EOL);
fwrite($file, '}' . PHP_EOL);
fclose($file);

echo 'Clonning messages definitions...', PHP_EOL;
`mkdir temp && cd temp && git clone git@github.com:Tarik02/cr-messages.git`;

echo 'Starting parsing messages...', PHP_EOL;

echo 'Parsing components...', PHP_EOL;
parseMessages('component', 'temp/cr-messages/component/', 'src/com/tarik02/clashroyale/server/protocol/messages/component/');
echo 'Parsing client messages...', PHP_EOL;
parseMessages('client', 'temp/cr-messages/client/', 'src/com/tarik02/clashroyale/server/protocol/messages/client/');
echo 'Parsing server messages...', PHP_EOL;
parseMessages('server', 'temp/cr-messages/server/', 'src/com/tarik02/clashroyale/server/protocol/messages/server/');

echo 'Writing handler file...', PHP_EOL;
writeHandlerFile();

//echo 'Removing temponary directory...', PHP_EOL;
//`rm -rf temp`;

function writeHandlerFile() {
	global $messages;
	global $definedMessages;

	$file = fopen('src/com/tarik02/clashroyale/server/protocol/Handler.java', 'w');
	fwrite($file, 'package royaleserver.protocol;' . PHP_EOL);
	fwrite($file, PHP_EOL);

	foreach ($messages['client'] as $name => $id) {
		if (isset($definedMessages[$id])) {
			fwrite($file, "import royaleserver.protocol.messages.client.$name;" . PHP_EOL);
		}
	}

	fwrite($file, PHP_EOL);
	fwrite($file, 'public interface Handler {' . PHP_EOL);
	foreach ($messages['client'] as $name => $id) {
		if (isset($definedMessages[$id])) {
			fwrite($file, INDENT . "boolean handle$name($name message) throws Throwable;" . PHP_EOL);
		}
	}
	fwrite($file, '}' . PHP_EOL);
	fclose($file);
}

function convertMessageName(string $name) {
	return strtoupper(preg_replace('/(.)([A-Z])/', '$1_$2', $name));
}

function parseMessages(string $label, string $input, string $output) {
	global $messages;
	global $definedMessages;

	`rm -rf $output && mkdir $output`;

	$base = $label === 'component' ? 'Component' : 'Message';
	foreach (listDirectory($input) as $name => $path) {
		$data = json_decode(file_get_contents($path), true);
		
		if ($base === 'Component') {
			$messageName = substr($name, 0, strrpos($name, '.'));
		} else {
			$messageName = $data['name'] = array_search($data['id'], $messages['client'] + $messages['server'], true);
			$definedMessages[$data['id']] = $messageName;
		}

		if (trim($messageName) === '') {
			continue;
		}

		$messageIdName = convertMessageName($messageName);

		$importFields = $classFields = $constructorFields = $encodeFields = $decodeFields = [];
		printFields($data['fields'] ?? [], $importFields, $classFields, $constructorFields, $encodeFields, $decodeFields);

		$file = fopen("src/com/tarik02/clashroyale/server/protocol/messages/$label/$messageName.java", 'w');
		fwrite($file, "package royaleserver.protocol.messages.$label;" . PHP_EOL);
		fwrite($file, PHP_EOL);

		if ($label === 'client') {
			fwrite($file, "import royaleserver.protocol.Handler;" . PHP_EOL);
		}

		fwrite($file, "import royaleserver.protocol.Info;" . PHP_EOL);
		fwrite($file, "import royaleserver.protocol.messages.$base;" . PHP_EOL);
		fwrite($file, "import royaleserver.utils.DataStream;" . PHP_EOL);

		if (count($importFields) !== 0) {
			fwrite($file, PHP_EOL);
			foreach ($importFields as $import) {
				fwrite($file, "import $import;" . PHP_EOL);
			}
		}

		fwrite($file, PHP_EOL);
		fwrite($file, "public class $messageName extends $base {" . PHP_EOL);

		if ($base === 'Message') {
			fwrite($file, INDENT . "public static final short ID = Info.$messageIdName;" . PHP_EOL);
			fwrite($file, PHP_EOL);
		}

		if (count($classFields) > 0) {
			foreach ($classFields as $name => $type) {
				fwrite($file, INDENT . "public $type $name;" . PHP_EOL);
			}
			fwrite ($file, PHP_EOL);
		}

		if (($base === 'Message') || (count($constructorFields) !== 0)) {
			fwrite($file, INDENT . "public $messageName() {" . PHP_EOL);

			if ($base === 'Message') {
				fwrite($file, INDENT2 . "super(ID);" . PHP_EOL);
				if (count($constructorFields) !== 0) {
					fwrite($file, PHP_EOL);
				}
			}

			foreach ($constructorFields as $field) {
				fwrite($file, INDENT2 . $field . PHP_EOL);
			}

			fwrite($file, INDENT . "}" . PHP_EOL);
			fwrite($file, PHP_EOL);
		}

		fwrite($file, INDENT . "@Override" . PHP_EOL);
		fwrite($file, INDENT . "public void encode(DataStream stream) {" . PHP_EOL);
		fwrite($file, INDENT2 . "super.encode(stream);" . PHP_EOL);
		if (count($encodeFields) > 0) {
			fwrite($file, PHP_EOL);
			foreach ($encodeFields as $field) {
				fwrite($file, INDENT2 . $field . PHP_EOL);
			}
		}
		fwrite($file, INDENT . "}" . PHP_EOL);
		fwrite($file, PHP_EOL);
		fwrite($file, INDENT . "@Override" . PHP_EOL);
		fwrite($file, INDENT . "public void decode(DataStream stream) {" . PHP_EOL);
		fwrite($file, INDENT2 . "super.decode(stream);" . PHP_EOL);
		if (count($decodeFields) > 0) {
			fwrite($file, PHP_EOL);
			foreach ($decodeFields as $field) {
				fwrite($file, INDENT2 . $field . PHP_EOL);
			}
		}
		fwrite($file, INDENT . "}" . PHP_EOL);

		if ($label === 'client') {
			fwrite($file, PHP_EOL);
			fwrite($file, INDENT . "public boolean handle(Handler handler) throws Throwable {" . PHP_EOL);
			fwrite($file, INDENT2 . "return handler.handle$messageName(this);" . PHP_EOL);
			fwrite($file, INDENT . "}" . PHP_EOL);
		}

		fwrite($file, "}" . PHP_EOL);
		fclose($file);
	}
}

function listDirectory(string $dir) {
	$result = [];

	foreach (array_filter(scandir($dir), function(string $name) {
		return !in_array($name, ['.', '..']);
	}) as $name) {
		$result[$name] = $dir . '/' . $name;
	}

	return $result;
}

function printFields(array $fields, array &$importFields = null, array &$classFields = null, array &$constructorFields, array &$encodeFields = null, array &$decodeFields = null) {
	static $Types = [
		'BOOLEAN' => [
			'javaType' => 'boolean',
			'streamName' => 'Boolean',
			'default' => 'false'
		], 'BYTE' => [
			'javaType' => 'byte',
			'streamName' => 'Byte',
			'default' => '0'
		], 'INT' => [
			'javaType' => 'int',
			'streamName' => 'BInt',
			'default' => '0'
		], 'INT32' => [
			'javaType' => 'int',
			'streamName' => 'VarInt32',
			'default' => '0'
		], 'RRSINT32' => [
			'javaType' => 'int',
			'streamName' => 'RrsInt32',
			'default' => '0'
		], 'RRSLONG' => [
			'javaType' => 'long',
			'streamName' => 'RrsLong',
			'default' => '0'
		], 'SCID' => [
			'javaType' => 'SCID',
			'streamName' => 'SCID',
			'default' => 'new SCID()',
			'importName' => 'royaleserver.utils.SCID'
		], 'LONG' => [
			'javaType' => 'long',
			'streamName' => 'BLong',
			'default' => '0'
		], 'STRING' => [
			'javaType' => 'String',
			'streamName' => 'String',
			'default' => '""'
		], 'BYTESET' => [
			'javaType' => 'byte[]',
			'streamName' => 'ByteSet',
			'default' => 'new byte[0]'
		], 'ZIP_STRING' => [
			'javaType' => 'String',
			'streamName' => 'ZipString',
			'default' => '""'
		], 'BITSET' => [
			'javaType' => 'Bitset',
			'streamName' => 'Bitset',
			'default' => 'new Bitset()',
			'importName' => 'royaleserver.utils.Bitset'
		], 'STATIC' => [
			'javaType' => 'byte[]',
			'streamName' => '',
			'default' => 'new byte[0]'
		]
	];

	if (!$importFields) {
		$importFields = [];
	}

	if (!$classFields) {
		$classFields = [];
	}

	if (!$constructorFields) {
		$constructorFields = [];
	}

	if (!$encodeFields) {
		$encodeFields = [];
	}

	if (!$decodeFields) {
		$decodeFields = [];
	}

	foreach ($fields as $i => $field) {
		$fieldType = $Types[$field['type']] ?? null;
		$isScalarField = $fieldType !== null;

		if ($field['type'] === 'IGNORE') {
			continue;
		}

		if (!$fieldType) {
			$openBracket = strpos($field['type'], '[');
			if ($openBracket === false) {
				$fieldType = [
					'javaType' => $field['type'],
					'default' => "new $field[type]()",
					'importName' => "royaleserver.protocol.messages.component.$field[type]"
				];
			} else {
				$closeBracket = strpos($field['type'], ']', $openBracket);
				assert($closeBracket !== false);

				if ($openBracket == $closeBracket - 1) {
					$field['type'] = substr($field['type'], 0, $openBracket);

					$fieldType = $Types[$field['type']] ?? null;
					if ($fieldType === null) {
						$fieldType = [
							'javaType' => $field['type'],
							'default' => "new $field[type]()",
							'defaultArray' => "new $field[type][0]",
							'importName' => "royaleserver.protocol.messages.component.$field[type]",
							'arrayType' => $field['lengthType'] ?? 'RRSINT32'
						];
					} else {
						$fieldType = $fieldType + [
							'defaultArray' => "new $fieldType[javaType][0]",
							'arrayType' => $field['lengthType'] ?? 'RRSINT32'
						];
					}
				} else {
					$count = intval(substr($field['type'], $openBracket + 1, $closeBracket - $openBracket - 1));
					$field['type'] = substr($field['type'], 0, $openBracket);

					$fieldType = $Types[$field['type']] ?? null;
					if ($fieldType === null) {
						$fieldType = [
							'javaType' => $field['type'],
							'default' => "new $field[type]()",
							'defaultArray' => "new $field[type][$count]",
							'importName' => "royaleserver.protocol.messages.component.$field[type]",
							'arrayType' => 'AUTO'
						];
					} else {
						$fieldType = $fieldType + [
							'defaultArray' => "new $fieldType[javaType][$count]",
							'arrayType' => 'AUTO'
						];
					}
				}
			}
		}

		if (!empty($fieldType['importName'])) {
			$importFields[$fieldType['importName']] = $fieldType['importName'];
		}

		if (empty($field['name'])) {
			$field['name'] = 'unknown_' . $i;
		}

		if ($isScalarField) {
			$classFields[$field['name']] = $fieldType['javaType'];
			$constructorFields []= "$field[name] = $fieldType[default];";
        	$encodeFields []= "stream.put$fieldType[streamName]($field[name]);";
			$decodeFields []= "$field[name] = stream.get$fieldType[streamName]();";
		} else if (isset($fieldType['arrayType'])) {
			$classFields[$field['name']] = $fieldType['javaType'] . '[]';
			$constructorFields []= "$field[name] = $fieldType[defaultArray];";
			if ($fieldType['arrayType'] !== 'AUTO') {
				$encodeFields []= "$field[name] = new $fieldType[javaType][stream.get" . $Types[$fieldType['arrayType']]['streamName'] . "()];";
				$decodeFields []= "stream.put" . $Types[$fieldType['arrayType']]['streamName'] . "((" . $Types[$fieldType['arrayType']]['javaType'] . ")$field[name].length);";
			}

			$encodeFields []= "for (int i = 0; i < $field[name].length; ++i) {";
			if (isset($fieldType['streamName'])) {
				$encodeFields []= INDENT . "stream.put$fieldType[streamName]($field[name][i]);";
			} else {
				$encodeFields []= INDENT . "$field[name][i].encode(stream);";
			}
			$encodeFields []= "}";
			$decodeFields []= "for (int i = 0; i < $field[name].length; ++i) {";
			if (isset($fieldType['streamName'])) {
				$decodeFields []= INDENT . "$field[name][i] = stream.get$fieldType[streamName]();";
			} else {
				$decodeFields []= INDENT . "$field[name][i] = $fieldType[default];";
				$decodeFields []= INDENT . "$field[name][i].decode(stream);";
			}
			$decodeFields []= "}";
		} else {
			if (isset($fieldType['defaultArray'])) {
				$classFields[$field['name']] = $fieldType['javaType'] . '[]';
				$constructorFields []= "$field[name] = $fieldType[defaultArray];";
			} else {
				$classFields[$field['name']] = $fieldType['javaType'];
				$constructorFields []= "$field[name] = $fieldType[default];";
			}

			$encodeFields []= "$field[name].encode(stream);";
			$decodeFields []= "$field[name].decode(stream);";
		}
	}
}
